# Copyright 2014 Lockheed Martin Corporation
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may 
# not use this file except in compliance with the License. You may obtain 
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software 
# distributed under the License is distributed on an "AS IS" BASIS, 
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and 
# limitations under the License.

---
extends: http://vwf.example.com/node3.vwf
implements:
  - source/griddable.vwf
properties:

  # gridSize - How many grid squares the object extends from its origin
  #
  # Minimum: [ 1, 1 ]
  gridSize: [ 1, 1 ]

  # collisionMap - The boundary map values to inject into the grid
  #
  # Impassable value: -1
  # Passable values: 0 and greater
  #
  # If replacesTerrain is true, both passable and impassible values
  # are injected into the grid
  # If replacesTerrain is false, only impassable values are injected
  #
  # Collision map is based on 0 rotation
  collisionMap: 
    - [ 0 ]

  # gridRotation - The rotation in degrees about the object's origin tile
  # valid values: 0, 90, 180, 270
  # Setting this will rotate the grid size and collision map accordingly
  gridRotation: 0

  # replacesTerrain - This object removes the terrain within its bounds
  replacesTerrain: false

  isOnGrid: false

methods:
  rotateObstacle:
events:
  addedToGrid:

scripts: |
  this.rotateObstacle = function( direction ) {
    direction = direction < 0 ? -1 : 1;
    var rotation = this.gridRotation + ( 90 * direction );
    rotation = rotation < 0 ? 360 + rotation : rotation % 360;
    this.updateCollisionMap( rotation );
    this.gridRotation = rotation;
  }

  this.addedToGrid = function( grid ) {
    for ( var x = 0; x < this.gridSize[ 0 ]; x++ ) {
      for ( var y = 0; y < this.gridSize[ 1 ]; y++ ) {
        if ( this.replacesTerrain || this.collisionMap[ x ][ y ] === -1 ) {
          var gridx = this.currentGridSquare[ 0 ] + x;
          var gridy = this.currentGridSquare[ 1 ] + y;
          grid.boundaryValues[ gridx ][ gridy ] = this.collisionMap[ x ][ y ];
        }
      }
    }

    this.rotateTo( [ 0, 0, 1, this.gridRotation ], 0 );

    // Adjust object position
    var posx = this.translation[ 0 ];
    posx += this.gridSize[ 0 ] * grid.gridSquareLength / 2;
    posx -= grid.gridSquareLength / 2;

    var posy = this.translation[ 1 ];
    posy += this.gridSize[ 1 ] * grid.gridSquareLength / 2;
    posy -= grid.gridSquareLength / 2;

    this.translateTo( [ posx, posy, this.translation[ 2 ] ], 0 );
    this.isOnGrid = true;
  }

  this.updateCollisionMap = function( angle ) {
    var tmp, delta;

    delta = angle - this.gridRotation;
    delta = delta < 0 ? 360 + delta : delta % 360;

    switch ( delta ) {
      case 90:
        this.invertGridSize.bind( this )();
        tmp = new Array();
        for ( var x = 0; x < this.gridSize[ 0 ]; x++ ) {
          tmp[ x ] = new Array();
          for ( var y = 0; y < this.gridSize[ 1 ]; y++ ) {
            tmp[ x ].push( this.collisionMap[ y ][ this.gridSize[ 0 ] - 1 - x ] );
          }
        }
        this.collisionMap = tmp;
        break;
      case 180:
        tmp = new Array();
        for ( var x = 0; x < this.gridSize[ 0 ]; x++ ) {
          tmp[ x ] = new Array();
          for ( var y = 0; y < this.gridSize[ 1 ]; y++ ) {
            tmp[ x ].push( this.collisionMap[ this.gridSize[ 0 ] - 1 - x ][ this.gridSize[ 1 ] - 1 - y ] );
          }
        }
        this.collisionMap = tmp;
        break;
      case 270:
        this.invertGridSize.bind( this )();
        tmp = new Array();
        for ( var x = 0; x < this.gridSize[ 0 ]; x++ ) {
          tmp[ x ] = new Array();
          for ( var y = 0; y < this.gridSize[ 1 ]; y++ ) {
            tmp[ x ].push( this.collisionMap[ this.gridSize[ 1 ] - 1 - y ][ x ] );
          }
        }
        this.collisionMap = tmp;
        break;
    }
  }

  this.invertGridSize = function() {
    var tmp;
    tmp = this.gridSize[ 0 ];
    this.gridSize[ 0 ] = this.gridSize[ 1 ];
    this.gridSize[ 1 ] = tmp;
  }

  //@ sourceURL=source/gridObstacle.vwf